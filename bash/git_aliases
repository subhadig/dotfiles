#!/usr/bin/env bash

alias gstatus='git status'
alias gbranch='git branch'
alias gadd='git add'
alias gaddall='git add -A'
alias gdiff='git diff'
alias glog='git log'
alias gc='git commit'
alias gcu='git commit -m "updated"'
alias gptm='git push origin master'
alias gpfm='git pull origin master'
alias gptc='git push origin `git branch --show-current`'
alias gpfc='git pull origin `git branch --show-current`'

# git add with fzf
gaf() {
    echo WARNING: This function is deprecated. Please use gafr instead.
    local file
    file=$(git status -s|grep '^.[^ ]'|fzf)
    if [ $? -ne 0 ]; then
        return
    fi
    echo Generating diff for selection: $file
    echo

    status=$(echo ${file}|awk '{print $1}')
    file=$(echo ${file}|awk '{print $2}')

    if [ $status = "??" -o $status = "db"  ]; then
        more "$file"
    else
        git diff "$file"
    fi

    echo
    read -p "Add to index? " choice
    if [ "$choice" = 'y' ]; then
        git add "$file"
        echo Added $file to index.
    else
        echo Aborting.
    fi
}

# git add with fzf recursive
gafr() {
    local file
    files=`git status -s|grep '^.[^ ]'`
    echo $files
    while true
    do
        file=`fzf <<< "$files"`
        if [ $? -ne 0 ]; then
            return
        fi
        echo Generating diff for selection: $file
        echo

        status=$(echo ${file}|awk '{print $1}')
        file=$(echo ${file}|awk '{print $2}')

        # It's very weird that on MacOS when the `git status -s` is being invoked
        # from within a script, for new files, the status is 'db' instead of '??'
        if [ $status = "??" -o $status = "db"  ]; then
            vi -R "$file"
        else
            git diff "$file"
        fi

        echo
        read -p "Add to index? " choice
        if [ "$choice" = 'y' ]; then
            git add "$file"
            echo Added $file to index.
            files=`grep -v "$file" <<<"$files"`
        else
            echo Aborting.
        fi
        if [ -z "$files" ]; then
            break
        fi
        read -p "Show next file? " choice
        if [ -n "$choice" -a ! "$choice" = 'y' ]; then
            break
        fi
    done
}

# Unstages a file but does not revert the changes
gresethead() {
    local file
    file=$(git diff --name-only --cached|fzf)
    if [ $? -ne 0 ]; then
        return
    fi
    if [ -f "$file" ]; then
        git reset HEAD "$file"
    fi
}

# Revert changes for a file.
grestore() {
    local file
    file=$(git diff --name-only|fzf)
    if [ $? -ne 0 ]; then
        return
    fi
    if [ -f "$file" ]; then
        git diff "$file"
        read -p "Restore file? " choice
        if [ "$choice" = 'y' ]; then
            git checkout -- "$file"
            echo Restored $file.
        else
            echo Aborting.
        fi
    fi
}

gsetconfigp() {
    git config user.name "Subhadip Ghosh"
    git config user.email "subhadipghosh11@gmail.com"

    echo Config updated!
    read -p "Also reset author for the last commit? " choice
    if [ "$choice" = 'y' ]; then
        git commit --amend --reset-author
    fi
}

printgaliases() {
    echo gstatus: Git status
    echo gbranch: Git branch
    echo gadd: Git add
    echo gaddall: Git add all files
    echo gdiff: Git diff
    echo glog: Git log
    echo gc: Git commit
    echo gcu: Git commit with comment "updated"
    echo gptm: Git push to master
    echo gpfm: Git pull from master
    echo gafr: Git add with fzf search. Recursive.
    echo gresethead: Git unstage a file but don\'t revert the changes with fzf search.
    echo grestore: Git restore a file to HEAD with fzf search.
    echo gsetconfigp: Git set user.name and user.email config to private.
}
